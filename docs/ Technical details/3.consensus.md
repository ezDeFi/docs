# Nexty Governance

This section will describe detail implementation of registration smart contract deployed at address 0x12345 using for consensus system.

4.1. Terminology

**sealer**: a participant in the Nexty consensus system. You can become one by depositing DEPOSIT_SIZE ZDs into the Nexty mechanism.

**active sealer set**: those sealer who are currently participating, and which the Nexty mechanism looks to seal blocks and other consensus objects.

**withdrawal period**: number of epochs between a sealer exit and the sealer balance being withdraw-able.

**coinbase**: the account address that sealer will use to sign when sealing block.

**registration contract**: a smart contract for handling Nexty consensus mechanism.

4.2. Constants

|Constant| Value| Unit|
|----------|---------|----|
|BLOCK_TIME| 2 |seconds|
|EPOCH_LENGTH| 3,000| blocks|
|DEPOSIT_SIZE| 20,000 |ZD|
|WITHDRAWAL_PERIOD| 30,000| blocks|

4.3. Sealer status codes

**PENDING_ACTIVE = 0**: Sealer
deposited enough ZDs into registration contract successfully.

**ACTIVE = 1**: Sealer send request to
become a sealer and added into activation sealer set successfully.

**PENDING_WITHDRAW = 2**:
Sealer send request to exit from activation sealer set successfully. Sealer casted out of activation sealer set.

**WITHDRAWN = 3**: Sealer already
withdrawn their deposit ZDs successfully. They can only make withdrawal after withdrawal period.

**PENALIZED = 127**: Sealer marked
as penalized node (update by consensus or voting result via dapp) and
cannot become active sealer and cannot withdraw balance neither.

4.4. Nexty chain registration contract

A registration contract is added to the Nexty
chain to deposit ZD and activation sealer
set management. It has some below basic
functions:

4.4.1. Sealer Operations

Deposit: Transfer the ZD from token holder to registration contract.
Sealer might have to approve contract to transfer an amount of ZD
before calling this function.

Join: To allow deposited ZD participate joining in as sealer. Participate already must deposit enough
ZD via Deposit function. it takes
coinbase as parameter.

Exit: Request to exit out of activation
sealer set.

Withdraw: To withdraw sealer’s ZD
balance when they already exited
and after withdrawal period.

4.4.2. Sealer Record.

Coinbase address: sealer’s coinbase
address to sign when sealing block

Balance: the total amount of ZD
that sealer has deposited

Status: Sealer status code
Requested Block Number: The
block number at which sealer send
request to exit out of activation
sealer set.

4.5. How to become a sealer

(1) A participant should deposit at least
DEPOSIT_SIZE ZD into registration contract, a.k.a the network have
maximum 200 candidate nodes can
become a sealer. Sealer status will
be set to PENDING_ACTIVE.

(2) A participant need to set their coinbase to seal the block and receive reward on their equivalent ZD token
holder address.

(3) A participant call registration contract method to become sealer.
Sealer status be updated to ACTIVE.

(4) At next checkpoint of the epoch,
sealer request be cast and the sealer
be added into consensus activation
sealer set.

4.6. How to exit from activation sealer
and ZD withdrawal.

(1) Sealer call registration contract
method to request for exiting
from activation sealer set and
sealer status be updated to PENDING_WITHDRAW but still in the
activation sealer set on the current
epoch.

(2) At next checkpoint of the epoch,
sealer exit request be cast and the
sealer be removed out of activation
sealer set.

(3) Sealer can call register contract
method to withdrawn their deposited ZD after a withdrawal period. The sealer status be changed to
WITHDRAWN after sealer withdraw
the ZD successfully.

4.7. Sealer authorization. When a node
starting with –mine option then they need
to unlock the unique coinbase account setting in the activation sealer set. If the coinbase was not found in the current epoch activation sealer set then unauthorization
error will be throw and it cannot start mining but they still can continue to sync block
preparing for sealing later.

4.8. Penalized. At the checkpoint of each
epoch, consensus will collect the data from
the chain to find out any sealers that didn’t
seal any blocks 3 epochs in a row. Then
to ensure the network healthy, those sealers will be removed out of the **activation sealer set** in the new epoch and mark
sealer’s status as PENALIZED. Because, offline sealers may due to the nature of unstable global network and dis-continue infrastructure service that out of control of the
sealers. Then all PENALIZED sealers then
can be unlock the slash after voting up by
NTY community via a specific voting smart
contract as well as dapp.

5. Block sealer reward calculation

Reward will be added immediately into
sealer’s account balance after sealing a
block. The reward for a block is equal
to the number of rewards per year divided
by **15,768,000**, the expected number of
block within one year (initial configuration
of block time is 2 seconds). The amount of
rewards of each block sealing in a specific
year is calculated in the following proportions:

|Year| % of total supply| Reward/Blk|
|----|-------|-----------|
|1 |10.000| 1,141|
|2| 5.000 |627|
|3| 2.500 |329|
|4 |1.250 |169|
|5 |0.625| 85|
|6| 0.500| 69|
|...| 0.500| ...|
|...| 0.500| ...|
|n |0.500| ...|

6. Anti-SPAM

6.1. Most Frequency Use. 

In Nexty
blockchain, we allow end user to perform
transaction with zero fee. Therefore, we
introduce a mechanism to priority transactions base on some other factors other than
using only the gasprice. The first factor is
similar to stamina, each account will have
a most frequency use state. whenever,
transaction from account to include in the
block then the most frequency use, ∆new,
will be update as following formula.

(9)
∆new = ∆old+max(1,(block − ∆old) ∗ GasUsed /(3 ∗ 21000))

**block**: is the block number that transaction was include.

**GasUsed**: gas used by the transaction

Ideally, the higher most frequency use
value, the less priority of the account’s transaction in the transaction pool. And each
time an account perform the transaction,
most frequency use value of that account
will be increase; as a result, the next transaction of the same account will be less priority. And to avoid spam by new account, the
most frequency use of a new account will
be the block number of the account’s first
transaction.

6.2. Transaction Parity 

Along with
most frequency use above, we introduce
a new factor to decide the priority of the
transaction called parity and will be calculated as below

(10)ρt = ∆act +TxGasLimit21000 − TxGasPrice / ParityLimit

∆act: most frequency use value of
the account when perform transaction

TxGasLimit: transaction gas limit,
the higher gas limit transaction, the
less priority

TxGasPrice: transaction gas price,
can be input arbitrarily by user.
User can put higher gas price if they
want to make transaction be confirmed faster.

ParityLimit: parity limit be configured by miner, the higher parity
limit, the less transaction gas price effect into the overall parity value, ρt

Overall, a transaction was include in the
miner’s txpool with priority base on the
value of transaction parity calculated in formula (10) then even though Nexty allow
user to send tnx with zero fee but sealer’s
pool can arbitrarily setting parameters to
utilize the sealer’s resource for anti spamming transaction and ensure normal user’s
transaction to be proceed without delay.

6.3. Transaction Proof of Work

In the
near future, when the Nexty chain will be
fulfilled or be spammed by unmeaning transactions, we will introduce a mechanism to
avoid those kind of problem by enforcing
user to send a proof of mini work along with
the transaction, the transaction with valid
proof will be sealed in the block with highest
priority. To make a better user experience
and adoption, we will develop this feature
in user wallet; when the transaction confirmation is too slow, wallet will allow user to
take action to do transaction proof of work
on their wallet before sending transaction.

# Relay-friendly, unbiasedly Randomized Proof of Stake

r2PoS is a Relay-friendly, unbiasedly Randomized Proof of Stake consensus, developed for the next upgrade of Nexty platform.

Sealers can be registered by staking ZD token and interact with the governance contract.
The sealing queue is constantly shuffled by an unbiasable VDF setup.
Secure stateless fast-sync, light-client, and can be relayed efficiently to any other smart-contract platform.
Cross-chain Data Relay
Relay data from one blockchain to another is expensive, mostly because the protocol of each involving blockchain does not actively support it. Relaying chain data and lightclient both require a protocol for the client to easily verify any data contained in the blockchain with only a small part of the chain data. A relay contract is also a light-client with even more limited resource.

BTCRelay contract is abandoned due to low activity. Relaying a single transaction requires all previous block headers from the last relayed one. PeaceRelay is not practical because it’s costing too much gas to verify an Ethash in the Ethereum contract platform itself.

Major blockchains have no support for trustless SPV/Lightclient protocol with optimal data and computation. That is, proving a transaction finality in an arbitrary block 
n
 require relaying much less data than 
n
 block headers.

Related works:

Non-Interactive Proofs of Proof-of-Work
Light Clients and Proof of Stake
Header-chain Protocol
Proof of Stake relies on the running state of the chain, which is not available in fast and light synchronization. The r2PoS protocol is designed for securing header-chain verification without the chain state. There is no epoch nor checkpoint, the sealing queue is constantly changed over each block, so the consensus depends on no single point of vulnerability nor performance bottleneck.

Sealer Application Confirmations
To participate in the sealing queue, one must have enough amount ZD token, which stays in the chain state. The required stake is verified by the governance contract, which also only available to full-state nodes. For secure stateless header-chain verification, each sealer application need 
τ
=
128
 confirmations to active. The stake requirement is verified by sealers, which are full-state nodes. After more than half of the queue confirm the application, it’s fully verified. Then the state-less clients can trust that application, having access to no chain state at all.



Inactivity Leakage
To keep the sealing queue healthy with the ever-changing sealers set, if a sealer hasn’t seal any block in λ=1024 blocks, it will be leaked out of the active queue. To join the queue again, ZD holder must re-apply the sealer in the governance contract.

### Sealing Queue

Given a header chain is verified up to block 
n − 1, the set of authorized sealers for the block n can be determined by:

S={si∣n − λ≤i<n} ∪ {a+j∣∣n−λ−τ≤j<n−τ}∖{a−j∣∣n−λ−τ≤j<n−τ}

Where si is the sealer of block i; a+j and a−j are the sealer joining and leaving application set of block j.

That is:

* All sealer of the last 1024 blocks [n−1024,n−1].
* And any sealer join application in [n−1024−128,n−1−128]
* Exclude any sealer leave application in [n−1024−128,n−1−128]

Sealing Queue can be deterministically reconstructed at any point in the header-chain, where the last n+λ+τ headers are verified. Reconstruction does not require any checkpoint, nor scanning more than λ + τ blocks.

### Finality and Recentness

A block in r2PoS is finalized after 
|
S
|
2
+
1
 confirmations, the chain can progress with just more than 
|
S
|
2
 active sealers.

To increase the rate of unique confirmation for anchor chain protocol, the last 
2
3
|
S
|
 block sealers are the recent signers and cannot seal the next block; hence the chain can only progress with more than 
2
3
|
S
|
 active sealers.

Randomness
The order and priority of the active sealing queue is shufled using the VDF calculation output as random seed. Input of the next VDF is the hash of the block containing the last VDF output. (See Unbiasable Randomness)



The VDF output can be included in any block to be available to the network as soon as possible. The block with the valid VDF output is prioritized by the protocol, allow it to override any other non-VDF block.

There’s no explicit incentive to calculate and publish the VDF output. But as one of the most valuable attributes of VDF, it requires only a single honest participant to secure the whole network, i.e. the randomization works even with only one sealer running the VDF calculation.

This setup prevents any kind of stake grinding or biasing. The only weakness is that it’s not realtime. As for every random seed, there’s a small time window that a specific sequence of sealers is known to authorize the upcoming blocks. What is not known is the order of the next sequence after a new random seed available.

Light-client/Relay Protocol
r2PoS is designed for trustless and efficient light client verification, allow relaying data from arbitrary block 
n
 with 
O
(
m
)
 data complexity, where 
m
 is the number of sealer applications up to block 
n
.

Cross-link chain
Cross-link is a block that contains consensus metadata necessary to verify the blocks followed. Every block is cryptographically linked to a cross-link, and each cross-link is linked to the last cross-link. A cross-link block is created when there’s an active change in the sealer queue, e.g. sealer join or leave.

This chain of cross-link blocks allows the light-client to skip all the blocks that has no affect to the consensus.



In the example diagram above, the cross-link chain only contains block number 6, 8 and 11. All other blocks in between have no effect on the consensus and can be ignored by light-clients.

Anchor chain
Anchor is the cryptographic link between cross-link blocks that share the super-majority common sealers. Anchor chain allows any block 
n
 can be relayed, or verified by light client with much less data than 
n
 headers.

With conflicted messages are assumed to be provable slashing condition, PoS requires 
|
C
|
>
|
S
|
2
 of unique confirmations for block finality. Blocks anchoring to the same anchor share the common sealer set of 
G
. To verify the finality of a block using the continuity anchor, only a set 
H
 of active sealer can be missing or left out. So we have:

|
G
|
−
|
H
|
>
|
C
|
>
|
S
|
2

|
H
|
<
|
G
|
−
|
S
|
2

So the set of header confirmations 
R
=
S
∖
H
 must be relayed with:

|
R
|
=
|
S
∖
H
|
>
3
2
|
S
|
−
|
G
|

Picking 
|
R
|
 and 
|
G
|
 is a matter of trading off between the consensus and relay protocol liveness. If we pick 
|
G
|
=
2
3
|
S
|
+
1
 (super majority), then we have:

|
R
|
≥
5
6
|
S
|

That means, the blocks with the same anchor must share more than 
2
3
 common sealers (a.k.a. majority continuity), and relaying a block requires 
5
6
 confirmations from the anchored sealer set.

Majority continuity
Let 
S
i
 and 
S
j
 is the sealer set of block 
i
 and 
j
. The majority continuity between the two blocks is preserved when 
|
Si∩
S
j
|
>
2
3
max
{
|
S
i
|
,
|
S
j
|
}
. This allows the validity and finality of block 
j
 can be verified with any 
5
6
 confirmations from the 
S
i
 sealer set.

Whenever the majority continuity is broken, a new anchor must be created, and the following blocks must anchor to this new anchor.



In the diagram above, block 8 and 11 shares the majority common sealers with block 6, so they are anchored to block 6. Block 13 breaks the continuity, even if it’s not a cross-link block, it will be turned into one and linked to the new anchor - block 11.

Chain size
The anchor chain grows at most 1 block for each 
1
3
|
S
|
 sealer application (i.e. join or leave). There’s no probability in (this version of) PoS, so logarithmic growing rate like PoPOW is not possible. Realistically, from the past data of PoS chains, the anchor chain size is often less than 1 over a millions of block headers. This is extremely optimal for PoS chain with quick block time and less frequent change of sealers.

Future Development
Signature chain
The header chain can be optimized for lightclient and relay, using multiple layers hashing. The first hashing layer must reveal only data for the consensus, just enough to verify the header chain and nothing else. All other block content will be hashed in the second layer.

BlockHash = Hash(ParentHash + ContentHash + Signagure)
That reduces the data size for each header from 573 bytes + 5 scalars to 129 bytes + 5 scalars. Without 5 scalars, that is about 77% data size saved for each block header.

The ContentHash is only verified when the block content is needed.

Off-chain Signature Service
Another approach to optimize the data size and calculation for header confirmations is to provide a layer 2 relay signature service. This service only works for relaying the latest part of the chain, which luckily, is most of the relay cases.

Active sealers can serve this service by signing the past block on request and providing the signature to the relayer. After collecting 
2
3
|
S
|
 signatures, relayer can submit them to the relay contract to prove finality of a block header, without bother with the header destructuring and chaining confirmations.

Ignoring 5 scalars, this methods save up to 88.6% of the data size for each block confirmations.

Threshold Signature
Theashold signature can be utilized for block finality, when such signature scheme is supported in major foreign chains.

Implementation
(In Progress)

Confirmation
A 
C
o
n
f
 object is identified by its hash and can be either:

A block header
Signed consensus fields (forward support for off-chain signature service) (TODO)
A 
C
o
n
f
 has one of the following states:

not available (not yet relayed)
available (relayed, but the sealer is not verified, used for chaining confirmations)
authorized (the sealer is authorized, by either cross-linked or anchored block)
finalized (has enough authorized 
C
o
n
f
s stacked after)
The (new) genesis block is hardcoded into the contract as the first finalized 
C
o
n
f
.

Queue
A 
Q
u
e
u
e
 is the ordered list of sealer addresses, recorded in the header extra. The 
Q
u
e
u
e
 of a 
C
o
n
f
 is relayed and verified only if the 
C
o
n
f
 is finalized.

As the consensus, only cross-linked and anchored block has the queue digest to be verified. A 
C
o
n
f
 can only be linked or anchored, if it’s finalized.

Verification
A 
C
o
n
f
 can be verified with its anchor or linked block, when its sealer is in the respective 
Q
u
e
u
e
.

Note that, a verified 
C
o
n
f
 alone is not a reliable data source, but a sequence of consecutive 
C
o
n
f
s with enough threshold of unique authorized sealers is collectively used for finalize relayed data.

Finalization
A 
C
o
n
f
 can be finalized with its anchor or linked block.

Anchor finalization requires:

its anchored 
Q
u
e
u
e
 is verified
there are at least 
5
6
|
Q
u
e
u
e
|
 authorized 
C
o
n
f
s in the following consecutive 
C
o
n
f
s (including the verifing 
C
o
n
f
)
Link finalization requires:

its linked 
Q
u
e
u
e
 is verified
there are at least 
|
Q
u
e
u
e
|
2
 authorized 
C
o
n
f
s in the following consecutive 
C
o
n
f
s (including the verifing 
C
o
n
f
)
In case of the anchor and cross-link majority continuity is broken, there’s a fail-back method to finalize a 
C
o
n
f
 by consequently apply each sealer applications by relaying governance contraction interaction txs and their signatures. (TODO)

With forward support for off-chain signature service, a 
C
o
n
f
 can be finalized only with bare signatures provided by the sealer in the 
Q
u
e
u
e
. (TODO)

Block Header Structure
Cross Link
Cross link hash is recorded in every header’s 
M
i
x
D
i
g
e
s
t
 (exclusive field for Ethash), which is the hash of the block that this header is linked to.

Anchor Link
Anchor is recorded in the header’s Extra, and only for the cross-link header.

Header Extra
Vanity (32 bytes)
Extended (optional)
AnchorData (optional)
SignatureByte = 0xFF
DestinationHash (32 bytes)
Q
u
e
u
e
D
i
g
e
s
t
 (32 bytes)
SealerApplication (optional/repeated)
Join = 0xF0
Address (20 bytes)
SealerApplication (optional/repeated)
Leave = 0xF1
Address (20 bytes)
SealerApplication (optional/repeated)
…
RandomData (optional)
SignatureByte = 0x01
VDFOutput (32 bytes)
PriceData (optional)
SignatureByte = 0x02
RLP(BigInt, BigInt)
Signature/Seal (65 bytes)
Queue Digest


The queue sealers is sorted alphabetically.

API
relayHeader(headerData...)
verifyQueue(headerHash, sealers[])
verifyHeader(headerHash)
constructQueue(headerHash)
finalize(headerHash, lastConfirmation)


